---
title: MySQL
layout: default
---

# MySQL







{: .warning }
> 解释一下阻塞的原因
>
> 当 `Session C` 请求 MDL 写锁时，**MySQL 会阻塞后续的所有 MDL 锁请求**，无论这些请求是读锁还是写锁。
>
> 也就是说，**在写锁的请求被阻塞后**，即便 `Session D` 只需要 MDL 读锁，也会被阻塞，必须等 `Session C` 的 MDL 写锁请求被处理完成（或者被撤销）之后，才能继续。
>
> 解释：
>
> 当有 MDL 写锁请求被阻塞（如 `Session C` 请求的写锁），**MySQL 会阻塞对该表的所有新的锁请求（包括读锁）**。这是为了避免 "饥饿" 问题，如果允许新的读锁继续执行，MDL 写锁就可能会永远得不到执行机会。因此，MySQL 的机制是：
>
> - 一旦有写锁请求阻塞，所有后续的读锁请求都会等待，以确保写锁能尽快获得执行的机会。

如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session再请求的话，这个库的线程很快就会爆满。





{: .warning-title }

> 解释一下阻塞的原因
>
> 当 `Session C` 请求 MDL 写锁时，**MySQL 会阻塞后续的所有 MDL 锁请求**，无论这些请求是读锁还是写锁。
>
> 也就是说，**在写锁的请求被阻塞后**，即便 `Session D` 只需要 MDL 读锁，也会被阻塞，必须等 `Session C` 的 MDL 写锁请求被处理完成（或者被撤销）之后，才能继续。
>
> 解释：
>
> 当有 MDL 写锁请求被阻塞（如 `Session C` 请求的写锁），**MySQL 会阻塞对该表的所有新的锁请求（包括读锁）**。这是为了避免 "饥饿" 问题，如果允许新的读锁继续执行，MDL 写锁就可能会永远得不到执行机会。因此，MySQL 的机制是：
>
> - 一旦有写锁请求阻塞，所有后续的读锁请求都会等待，以确保写锁能尽快获得执行的机会。

如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session再请求的话，这个库的线程很快就会爆满。



{: .fixme}

> 我请问呢？
>
> 可以吗？
